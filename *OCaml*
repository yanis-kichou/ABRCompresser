        OCaml version 4.05.0

# (* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)
(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::[]->if(v=x)then []
  |v::r::xs->if(x=r)then
               v::xs
let extraction_alea L P =
  let rec loop lis acc=
    match lis with
    |[]->acc
    |l->loop;;
                                      Characters 443-445:
      |l->loop;;
              ^^
Error: Syntax error
# (* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)
(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::[]->if(v=x)then []
  |v::r::xs->if(x=r)then
               v::xs
(*let extraction_alea L P =
  let rec loop lis acc=
    match lis with
    |[]->acc
    |l->loop*);;
                              * * * * Characters 300-302:
    |v::[]->if(v=x)then []
                        ^^
Error: This variant expression is expected to have type unit
       The constructor [] does not belong to type unit
# (* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)
(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::[]->if(v=x)then
            []
          else
            v::[]
  |v::r::xs->if(x=r)then
               v::xs
(*let extraction_alea L P =
  let rec loop lis acc=
    match lis with
    |[]->acc
    |l->loop*);;
                                    * * * * Characters 389-391:
                 v::xs
                  ^^
Error: This variant expression is expected to have type unit
       The constructor :: does not belong to type unit
# (* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)
(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::[]->if(v=x)then
            []
          else
            v::[]
  |v::r::xs->if(x=r)then
               v::xs
             else
               v::r::(remove xs x)
(*let extraction_alea L P =
  let rec loop lis acc=
    match lis with
    |[]->acc
    |l->loop*);;
                                        * * * * val get : 'a list -> int -> 'a = <fun>
val remove : 'a list -> 'a -> 'a list = <fun>
# (* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::[]->if(v=x)then
            []
          else
            v::[]
  |v::r::xs->if(x=r)then
               v::xs
             else
               v::r::(remove xs x)
(*let extraction_alea L P =
  let rec loop lis acc=
    match lis with
    |[]->acc
    |l->loop*);;
                                          * * * * val get : 'a list -> int -> 'a = <fun>
val remove : 'a list -> 'a -> 'a list = <fun>
# get [2;3;4] 0;;
- : int = 2
# get [2;3;4] 1;;
- : int = 3
# get [2;3;4] 3;;
Exception: Failure "list vide".
# get [2;3;4] 2;;
- : int = 4
# remove [2;3;4] 3
;;
  - : int list = [2; 4]
# remove [2;3;4] 0;;

- : int list = [2; 3; 4]
#   (* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::[]->if(v=x)then
            []
          else
            v::[]
  |v::r::xs->if(x=r)then
               v::xs
             else
               v::r::(remove xs x)
let extraction_alea L P =
  let rec loop lis acc=
    let l=(List.length L) in 
    match lis with
    |[]->acc
    |l-> let x=(get lis (Random.int  l)in
                loop (remove lis x)(x::acc)
                in
                loop L P;;
                                                          Characters 576-577:
      |l-> let x=(get lis (Random.int  l)in
                 ^
Syntax error: ')' expected, the highlighted '(' might be unmatched
# (* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::[]->if(v=x)then
            []
          else
            v::[]
  |v::r::xs->if(x=r)then
               v::xs
             else
               v::r::(remove xs x)
let extraction_alea L P =
  let rec loop lis acc=
    let l=(List.length L) in 
    match lis with
    |[]->acc
    |l-> let x=get lis (Random.int  l)in
                loop (remove lis x)(x::acc)
                in
                loop L P;;
                                                          Characters 468-469:
  let extraction_alea L P =
                      ^
Error: Unbound constructor L
# (* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::[]->if(v=x)then
            []
          else
            v::[]
  |v::r::xs->if(x=r)then
               v::xs
             else
               v::r::(remove xs x)
let extraction_alea L P =
  let rec loop lis acc=
    let l=(List.length L) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  xl)in
         loop (remove lis x)(x::acc)
  in
  loop L P;;
                                                          Characters 468-469:
  let extraction_alea L P =
                      ^
Error: Unbound constructor L
# (* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::[]->if(v=x)then
            []
          else
            v::[]
  |v::r::xs->if(x=r)then
               v::xs
             else
               v::r::(remove xs x)
let extraction_alea L P =
  let rec loop lis acc=
    let l=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  xl)in
         loop (remove lis x)(x::acc)
  in
  loop L P;;
                                                          Characters 468-469:
  let extraction_alea L P =
                      ^
Error: Unbound constructor L
# (* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::[]->if(v=x)then
            []
          else
            v::[]
  |v::r::xs->if(x=r)then
               v::xs
             else
               v::r::(remove xs x)

(* Premiere fonction extraction_alea*)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
         loop (remove lis x)(x::acc)
  in
  loop L P;;
                                                              Characters 693-694:
    loop L P;;
         ^
Error: This variant expression is expected to have type 'a list
       The constructor L does not belong to type list
# (* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::[]->if(v=x)then
            []
          else
            v::[]
  |v::r::xs->if(x=r)then
               v::xs
             else
               v::r::(remove xs x)

(* Premiere fonction extraction_alea*)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
         loop (remove lis x)(x::acc)
  in
  loop l p;;
                                                              val get : 'a list -> int -> 'a = <fun>
val remove : 'a list -> 'a -> 'a list = <fun>
val extraction_alea : 'a list -> 'a list -> 'a list = <fun>
# extraction_alea [1;2;3] [7;1;5];;
- : int list = [1; 3; 1; 2; 1; 7; 1; 5]
# (* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::[]->if(v=x)then
            []
          else
            v::[]
  |v::r::xs->if(x=r)then
               v::xs
             else
               v::r::(remove xs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

*)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->[]
    |xl-> let x=get lis (Random.int  t)in
         loop (remove lis x)(x::acc)
  in
  loop l p
    
let;;
                                            * * * * * *                       Characters 845-847:
  let;;
     ^^
Error: Syntax error
# (* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::[]->if(v=x)then
            []
          else
            v::[]
  |v::r::xs->if(x=r)then
               v::xs
             else
               v::r::(remove xs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

*)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
         loop (remove lis x)(x::acc)
  in
  loop l p
    
let;;
                                            * * * * * *                       Characters 846-848:
  let;;
     ^^
Error: Syntax error
# (* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::[]->if(v=x)then
            []
          else
            v::[]
  |v::r::xs->if(x=r)then
               v::xs
             else
               v::r::(remove xs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

*)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
         loop nvList (x::acc)
  in
  loop l p;;
                                            * * * * * *                     val get : 'a list -> int -> 'a = <fun>
val remove : 'a list -> 'a -> 'a list = <fun>
val extraction_alea : 'a list -> 'a list -> 'a list = <fun>
# extraction_alea [1;2;3] [7;1;5];;
- : int list = [1; 2; 1; 1; 3; 7; 1; 5]
# extraction_alea [1;2;3] [7;1;5];;(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::[]->if(v=x)then
            []
          else
            v::[]
  |v::r::xs->if(x=r)then
               v::xs
             else
               v::r::(remove xs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

*)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
         loop nvList nacc
  in
  loop l p;;
                                            * * * * * *                       val get : 'a list -> int -> 'a = <fun>
val remove : 'a list -> 'a -> 'a list = <fun>
val extraction_alea : 'a list -> 'a list -> 'a list = <fun>
# extraction_alea [1;2;3] [7;1;5];;
- : int list = [1; 2; 3; 1; 7; 1; 5]
# extraction_alea [1;2;3] [7;1;5];;
- : int list = [1; 2; 1; 3; 7; 1; 5]
# l=[1;2;3]
      ;;
  Characters 0-1:
  l=[1;2;3]
  ^
Error: Unbound value l
# let l = [1;2;3];;
val l : int list = [1; 2; 3]
# remove l 1 ;;
- : int list = [1; 2; 3]
# let l=remove l 1 ;;
val l : int list = [1; 2; 3]
# remove [1;2] 2
;;
  - : int list = [1]
# remove l 2 ;;
- : int list = [1; 3]
# remove l 1 ;;
- : int list = [1; 2; 3]
# let l= remove l 2 in l
			 ;;
  - : int list = [1; 3]
# l;;
- : int list = [1; 2; 3]
# let l = remove l 2 ;;
val l : int list = [1; 3]
# l
;;
  - : int list = [1; 3]
# let l = remove l 1 ;;
val l : int list = [1; 3]
# (* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::[]->if(v==x)then
            []
          else
            v::[]
  |v::r::xs->if(x==r)then
               v::xs
             else
               v::r::(remove xs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

*)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
         loop nvList nacc
  in
  loop l p;;
                                            * * * * * *                       val get : 'a list -> int -> 'a = <fun>
val remove : 'a list -> 'a -> 'a list = <fun>
val extraction_alea : 'a list -> 'a list -> 'a list = <fun>
# let l = [2;3;4] ;;
val l : int list = [2; 3; 4]
# let l=remove l 2;;
val l : int list = [2; 3; 4]
# remove [1;2;3]  1;;
- : int list = [1; 2; 3]
# remove l 3;;
- : int list = [2; 4]
# remove (remove l 3 ) 4
;;
  - : int list = [2]
# remove (remove (remove l 3 ) 4)2;;
;;
- : int list = []
# # (* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

*)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
         loop nvList nacc
  in
  loop l p;;
                                    * * * * * *                       val get : 'a list -> int -> 'a = <fun>
val remove : 'a list -> 'a -> 'a list = <fun>
val extraction_alea : 'a list -> 'a list -> 'a list = <fun>
# remove [2;3;4] 3;;
- : int list = [2; 4]
# remove [2;3;4] 2;;
- : int list = [3; 4]
# extraction_alea [1;2;3] [7;1;5];;
- : int list = [1; 2; 3; 7; 1; 5]
# extraction_alea [1;2;3] [7;1;5];;
- : int list = [3; 1; 2; 7; 1; 5]
# extraction_alea [1;2;3] [7;1;5];;
- : int list = [3; 1; 2; 7; 1; 5]
# extraction_alea [1;2;3] [7;1;5];;
- : int list = [3; 2; 1; 7; 1; 5]
# extraction_alea [1;2;3] [7;1;5];;
- : int list = [3; 1; 2; 7; 1; 5]
# extraction_alea [1;2;3;7;8;5;6] [7;1;5;8];;
- : int list = [8; 6; 1; 3; 7; 2; 5; 7; 1; 5; 8]
# (* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis [];;
                                    * * * * * *                                               val get : 'a list -> int -> 'a = <fun>
val remove : 'a list -> 'a -> 'a list = <fun>
val extraction_alea : 'a list -> 'a list -> 'a list = <fun>
val create_List : int -> int list = <fun>
val gen_permutation : int -> int list = <fun>
# gen_permutation 5;;
- : int list = [2; 3; 4; 1; 5]
# gen_permutation 4;;
- : int list = [2; 4; 3; 1]
# gen_permutation 6;;
- : int list = [5; 1; 4; 3; 2; 6]
# (*****************************************)
(*               Type                    *)

type a' tree=Empty| Node of (a'*a' tree *a'tree)

(*****************************************)





(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis [];;
                                                          * * * * * *                                               Characters 97-101:
Error: Syntax error
# (*****************************************)
(*               Type                    *)

type a' tree=Empty| Node of (a',a' tree,a'tree)

(*****************************************)





(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis [];;
                                                          * * * * * *                                               Characters 97-101:
Error: Syntax error
# (*****************************************)
(*               Type                    *)

type a' tree=Empty| Node of ( a' * a' tree * a'tree)

(*****************************************)





(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis [];;
                                                          * * * * * *                                               Characters 97-101:
Error: Syntax error
# (*****************************************)
(*               Type                    *)

(*type a' tree=Empty| Node of ( a' * a' tree * a'tree)*)

(*****************************************)





(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis [];;
                                                          * * * * * *                                               val get : 'a list -> int -> 'a = <fun>
val remove : 'a list -> 'a -> 'a list = <fun>
val extraction_alea : 'a list -> 'a list -> 'a list = <fun>
val create_List : int -> int list = <fun>
val gen_permutation : int -> int list = <fun>
# (*****************************************)
(*               Type                    *)

type a' ABR=Empty| Node of ( a' * a' ABR * a' ABR)
(*****************************************)





(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis [];;
                                                        * * * * * *                                               Characters 97-100:
Error: Syntax error
# (*****************************************)
(*               Type                    *)

type a' ABR=Empty| Node of ( a' , a' ABR , a' ABR)
(*****************************************)





(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis [];;
                                                        * * * * * *                                               Characters 97-100:
Error: Syntax error
# (*****************************************)
(*               Type                    *)

type a' tree= Empty
           |Node of ( a' , a' tree , a' tree)
(*****************************************)
       




(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis [];;
                                                          * * * * * *                                               Characters 97-101:
Error: Syntax error
# (*****************************************)
(*               Type                    *)

type a' Tree= Empty
           |Node of ( a' , a' Tree , a' Tree)
(*****************************************)
       




(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis [];;
                                                          * * * * * *                                               Characters 97-101:
Error: Syntax error
# (*****************************************)
(*               Type                    *)

type a'Tree= Empty
           |Node of ( a' , a'Tree , a'Tree)
(*****************************************)
       




(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis [];;
                                                          * * * * * *                                               Characters 260-263:
Error: Syntax error
# (*****************************************)
(*               Type                    *)

type a' Tree= Empty
           |Node of ( a', a'Tree, a'Tree)
(*****************************************)
       




(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis [];;
                                                          * * * * * *                                               Characters 97-101:
Error: Syntax error
# (*****************************************)
(*               Type                    *)

type a' tree  = Empty
           |Node of ( a', a' tree, a' tree)
(*****************************************)
       




(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis [];;
                                                          * * * * * *                                               Characters 97-101:
Error: Syntax error
# (*****************************************)
(*               Type                    *)

type a' tree  = Empty
           |Node of ( a', a' tree, a' tree) ;;
(*****************************************)
       




(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis [];;
        Characters 97-101:
  type a' tree  = Empty
          ^^^^
Error: Syntax error
#                                                 * * * * * *                                               val get : 'a list -> int -> 'a = <fun>
val remove : 'a list -> 'a -> 'a list = <fun>
val extraction_alea : 'a list -> 'a list -> 'a list = <fun>
val create_List : int -> int list = <fun>
val gen_permutation : int -> int list = <fun>
# (*****************************************)
(*               Type                    *)

type a' tree  = Empty| Node  of ( a'* a' tree * a' tree) ;;
(*****************************************)
       




(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis [];;
      Characters 97-101:
  type a' tree  = Empty| Node  of ( a'* a' tree * a' tree) ;;
          ^^^^
Error: Syntax error
#                                                 * * * * * *                                               val get : 'a list -> int -> 'a = <fun>
val remove : 'a list -> 'a -> 'a list = <fun>
val extraction_alea : 'a list -> 'a list -> 'a list = <fun>
val create_List : int -> int list = <fun>
val gen_permutation : int -> int list = <fun>
# (*****************************************)
(*               Type                    *)

let a' tree  = Empty| Node  of ( a'* a' tree * a' tree) ;;
(*****************************************)
       




(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis [];;
      Characters 109-110:
  let a' tree  = Empty| Node  of ( a'* a' tree * a' tree) ;;
                      ^
Error: Syntax error
#                                                 * * * * * *                                               val get : 'a list -> int -> 'a = <fun>
val remove : 'a list -> 'a -> 'a list = <fun>
val extraction_alea : 'a list -> 'a list -> 'a list = <fun>
val create_List : int -> int list = <fun>
val gen_permutation : int -> int list = <fun>
# (*****************************************)
(*               Type                    *)

type a' tree  = Empty| Node  of  a'* a' tree * a' tree ;;
(*****************************************)
       




(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis [];;
      Characters 97-101:
  type a' tree  = Empty| Node  of  a'* a' tree * a' tree ;;
          ^^^^
Error: Syntax error
#                                                 * * * * * *                                               val get : 'a list -> int -> 'a = <fun>
val remove : 'a list -> 'a -> 'a list = <fun>
val extraction_alea : 'a list -> 'a list -> 'a list = <fun>
val create_List : int -> int list = <fun>
val gen_permutation : int -> int list = <fun>
# (*****************************************)
(*               Type                    *)

type 'a tree  = Empty| Node  of  ('a* 'a tree * 'a tree) ;;
(*****************************************)
       




(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis [];;
      type 'a tree = Empty | Node of ('a * 'a tree * 'a tree)
#                                                 * * * * * *                                               val get : 'a list -> int -> 'a = <fun>
val remove : 'a list -> 'a -> 'a list = <fun>
val extraction_alea : 'a list -> 'a list -> 'a list = <fun>
val create_List : int -> int list = <fun>
val gen_permutation : int -> int list = <fun>
# (*****************************************)
(*               Type                    *)

type 'a tree  = Empty| Node  of  'a* 'a tree * 'a tree
(*****************************************)
       




(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis [];;
                                                        * * * * * *                                               type 'a tree = Empty | Node of 'a * 'a tree * 'a tree
val get : 'a list -> int -> 'a = <fun>
val remove : 'a list -> 'a -> 'a list = <fun>
val extraction_alea : 'a list -> 'a list -> 'a list = <fun>
val create_List : int -> int list = <fun>
val gen_permutation : int -> int list = <fun>
# let a = Node(5,Empty,Empty);;
val a : int tree = Node (5, Empty, Empty)
# (*****************************************)
(*               Type                    *)

type 'a tree  = Empty| Node  of  'a* 'a tree * 'a
                               
(*****************************************)
(*             Primitive                 *)
let create n=Node(n,Empty,Empty)
let rec insert abr v =
  match abr with
  |Empty->create v
  |Node (x,fg,fd)->if(x>v)then
                     Node (x,(insert fg v),fd)
                   else
                      Node (x,fg,(insert fd v))



(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis [];;
                                                                        * * * * * *                                               Characters 494-496:
Error: This expression has type 'a tree
       but an expression was expected of type 'a tree tree
# (*****************************************)
(*               Type                    *)

type 'a tree  = Empty| Node  of  'a* 'a tree * 'a
                               
(*****************************************)
(*             Primitive                 *)
let create n=Node(n,Empty,Empty);;
let rec insert abr v =
  match abr with
  |Empty->create v
  |Node (x,fg,fd)->if(x>v)then
                     Node (x,(insert fg v),fd)
                   else
                      Node (x,fg,(insert fd v))



(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis [];;
              type 'a tree = Empty | Node of 'a * 'a tree * 'a
val create : 'a tree -> 'a tree tree = <fun>
#                                                         * * * * * *                                               Characters 202-204:
Error: This expression has type 'a tree
       but an expression was expected of type 'a tree tree
# (*****************************************)
(*               Type                    *)

type 'a tree  = Empty| Node  of  'a* 'a tree * 'a tree
                               
(*****************************************)
(*             Primitive                 *)
let create n=Node(n,Empty,Empty)
           
let rec insert abr v =
  match abr with
  |Empty->create v
  |Node (x,fg,fd)->if(x>v)then
                     Node (x,(insert fg v),fd)
                   else
                     Node (x,fg,(insert fd v))
                 
                 
                 
(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis [];;
                                                                          * * * * * *                                               type 'a tree = Empty | Node of 'a * 'a tree * 'a tree
val create : 'a -> 'a tree = <fun>
val insert : 'a tree -> 'a -> 'a tree = <fun>
val get : 'a list -> int -> 'a = <fun>
val remove : 'a list -> 'a -> 'a list = <fun>
val extraction_alea : 'a list -> 'a list -> 'a list = <fun>
val create_List : int -> int list = <fun>
val gen_permutation : int -> int list = <fun>
# (*****************************************)
(*               Type                    *)

type 'a tree  = Empty| Node  of  'a* 'a tree * 'a tree
                               
(*****************************************)
(*             Primitive                 *)
let create n=Node(n,Empty,Empty)
           
let rec insert abr v =
  match abr with
  |Empty->create v
  |Node (x,fg,fd)->if(x>v)then
                     Node (x,(insert fg v),fd)
                   else
                     Node (x,fg,(insert fd v))
                 
                 
(*exerice 1*) 
(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis [];;
                                                                          * * * * * *                                               type 'a tree = Empty | Node of 'a * 'a tree * 'a tree
val create : 'a -> 'a tree = <fun>
val insert : 'a tree -> 'a -> 'a tree = <fun>
val get : 'a list -> int -> 'a = <fun>
val remove : 'a list -> 'a -> 'a list = <fun>
val extraction_alea : 'a list -> 'a list -> 'a list = <fun>
val create_List : int -> int list = <fun>
val gen_permutation : int -> int list = <fun>
# (*****************************************)
(*               Type                    *)

type 'a tree  = Empty| Node  of  ('a* 'a tree * 'a tree)
                               
(*****************************************)
(*             Primitive                 *)
let create n=Node(n,Empty,Empty)
           
let rec insert abr v =
  match abr with
  |Empty->create v
  |Node (x,fg,fd)->if(x>v)then
                     Node (x,(insert fg v),fd)
                   else
                     Node (x,fg,(insert fd v))
                 
                 
(*exerice 1*) 
(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis [];;
                                                                          * * * * * *                                               type 'a tree = Empty | Node of ('a * 'a tree * 'a tree)
val create : 'a -> 'a tree = <fun>
val insert : 'a tree -> 'a -> 'a tree = <fun>
val get : 'a list -> int -> 'a = <fun>
val remove : 'a list -> 'a -> 'a list = <fun>
val extraction_alea : 'a list -> 'a list -> 'a list = <fun>
val create_List : int -> int list = <fun>
val gen_permutation : int -> int list = <fun>
# (*****************************************)
(*               Type                    *)

type 'a tree  = Empty| Node  of  ('a* 'a tree * 'a tree)
                               
(*****************************************)
(*             Primitive                 *)
let create n=Node(n,Empty,Empty)
           
let rec insert abr v =
  match abr with
  |Empty->create v
  |Node (x,fg,fd)->if(x>v)then
                     Node (x,(insert fg v),fd)
                   else
                     Node (x,fg,(insert fd v))
                 
                 
(*exerice 1*) 
(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis []
  


(*exercice 2*)
let ABRfromList l=
  let rec loop lis abr =
  match lis with
  |[]->abr
  |x::xs-> loop xs (insert abr x)
  in
  loop l Empty;;
                                                                          * * * * * *                                                                     Characters 1655-1666:
Error: Unbound constructor ABRfromList
# insert Empty 5;;
- : int tree = Node (5, Empty, Empty)
# (*****************************************)
(*               Type                    *)

type 'a tree  = Empty| Node  of  ('a* 'a tree * 'a tree)
                               
(*****************************************)
(*             Primitive                 *)
let create n=Node(n,Empty,Empty)
           
let rec insert abr v =
  match abr with
  |Empty->create v
  |Node (x,fg,fd)->if(x>v)then
                     Node (x,(insert fg v),fd)
                   else
                     Node (x,fg,(insert fd v))
                 
                 
(*exerice 1*) 
(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis []
  


(*exercice 2*)

let ABRfromList l=
  let rec loop lis abr =
    match lis with
    |[]->abr
    |x::xs-> loop xs (insert abr x)
  in
  loop l Empty;;
                                                                          * * * * * *                                                                       Characters 1656-1667:
Error: Unbound constructor ABRfromList
# (*****************************************)
(*               Type                    *)

type 'a tree  = Empty| Node  of  ('a* 'a tree * 'a tree)
                               
(*****************************************)
(*             Primitive                 *)
let create n=Node(n,Empty,Empty)
           
let rec insert abr v =
  match abr with
  |Empty->create v
  |Node (x,fg,fd)->if(x>v)then
                     Node (x,(insert fg v),fd)
                   else
                     Node (x,fg,(insert fd v))
                 
                 
(*exerice 1*) 
(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis []
  


(*exercice 2*)

let ABRfromList l =
  let rec loop2 lis abr =
    match lis with
    |[]->abr
    |x::xs-> loop xs (insert abr x)
  in
  loop2 l Empty;;
                                                                          * * * * * *                                                                       Characters 1656-1667:
Error: Unbound constructor ABRfromList
# (*****************************************)
(*               Type                    *)

type 'a tree  = Empty | Node  of  ('a* 'a tree * 'a tree)
                               
(*****************************************)
(*             Primitive                 *)
let create n=Node(n,Empty,Empty)
           
let rec insert abr v =
  match abr with
  |Empty->create v
  |Node (x,fg,fd)->if(x>v)then
                     Node (x,(insert fg v),fd)
                   else
                     Node (x,fg,(insert fd v))
                 
                 
(*exerice 1*) 
(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis []
  


(*exercice 2*)

let ABRfromList l =
  let rec loop2 lis abr =
    match lis with
    |[]->abr
    |x::xs-> loop xs (insert abr x)
  in
  loop2 l Empty;;
                                                                          * * * * * *                                                                       Characters 1657-1668:
Error: Unbound constructor ABRfromList
# (*****************************************)
(*               Type                    *)

type 'a tree  = Empty | Node  of  ('a* 'a tree * 'a tree)
                               
(*****************************************)
(*             Primitive                 *)
let create n=Node(n,Empty,Empty)
           
let rec insert abr v =
  match abr with
  |Empty->create v
  |Node (x,fg,fd)->if(x>v)then
                     Node (x,(insert fg v),fd)
                   else
                     Node (x,fg,(insert fd v))
                 
                 
(*exerice 1*) 
(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis []
  


(*exercice 2*)

let ABRfromList l =
  let rec loop2 lis abr =
    match lis with
    |[]->abr
    |x::xs-> loop2 xs (insert abr x)
  in
  loop2 l Empty;;
                                                                          * * * * * *                                                                       Characters 1657-1668:
Error: Unbound constructor ABRfromList
# (*****************************************)
(*               Type                    *)

type 'a tree  = Empty | Node  of  ('a* 'a tree * 'a tree)
                               
(*****************************************)
(*             Primitive                 *)
let create n=Node(n,Empty,Empty)
           
let rec insert abr v =
  match abr with
  |Empty->create v
  |Node (x,fg,fd)->if(x>v)then
                     Node (x,(insert fg v),fd)
                   else
                     Node (x,fg,(insert fd v))
                 
                 
(*exerice 1*) 
(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis []
  


(*exercice 2*)

let ABRfromList l =
  let rec loop2 lis abr =
    match lis with
    |[]->abr
    |x::xs-> loop2 xs (insert abr x)
  in
  loop2 l Empty;;
                                                                          * * * * * *                                                                       Characters 1657-1668:
Error: Unbound constructor ABRfromList
# (*****************************************)
(*               Type                    *)

type 'a tree  = Empty | Node  of  ('a* 'a tree * 'a tree)
                               
(*****************************************)
(*             Primitive                 *)
let create n=Node(n,Empty,Empty)
           
let rec insert abr v =
  match abr with
  |Empty->create v
  |Node (x,fg,fd)->if(x>v)then
                     Node (x,(insert fg v),fd)
                   else
                     Node (x,fg,(insert fd v))
                 
                 
(*exerice 1*) 
(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis []
  


(*exercice 2*)

let ABRfromListe l =
  let rec loop liste acc =
    match liste with
    |[]->acc
    |x::xs-> loop xs (insert acc x)
  in
  loop l Empty;;
                                                                          * * * * * *                                                                       Characters 1657-1669:
Error: Unbound constructor ABRfromListe
# (***********
   
   ******************************)
(*               Type                    *)

type 'a tree  = Empty | Node  of  ('a* 'a tree * 'a tree)
                               
(*****************************************)
(*             Primitive                 *)
let create n=Node(n,Empty,Empty)
           
let rec insert abr v =
  match abr with
  |Empty->create v
  |Node (x,fg,fd)->if(x>v)then
                     Node (x,(insert fg v),fd)
                   else
                     Node (x,fg,(insert fd v))
                 
                 
(*exerice 1*) 
(* fonction qui retourne l'elements a l'indice i *)
let rec get l i=
  match l with
  |[]->failwith "list vide"
  |x::xs->if(i=0)then
           x
         else
           get xs (i-1)

(*fonction qui enleve l'element i de la list*)
let rec remove l x =
  match l with
  |[]->[]
  |v::vs->if(v==x)then
            vs
          else
            v::(remove vs x)

(* Premiere fonction : extraction_alea
   prend deux lists L et P
   choisit un element parmis L 
   l'empile en tete de P 
   et refait l'operation jusqu'a ce que L est vide 

 *)
let extraction_alea l p =
  let rec loop lis acc=
    let t=(List.length lis) in 
    match lis with
    |[]->acc
    |xl-> let x=get lis (Random.int  t)in
          let nvList=(remove lis x)in
          let nacc=x::acc in
          loop nvList nacc
  in
  loop l p
  
(*fonction qui cree une liste trier appartir d'un nombre n *)
let rec create_List n =
  if(n==0)then
    []
  else
    n::(create_List (n-1))

(* fonction gen_permutation *)
let gen_permutation n=
  let lis=create_List n in
  extraction_alea lis []
  


(*exercice 2*)

let ListetoABR l =
  let rec loop liste acc =
    match liste with
    |[]->acc
    |x::xs-> loop xs (insert acc x)
  in
  loop l Empty;;
                                                                          * * * * * *                                                                       Characters 1657-1667:
Error: Unbound constructor ListetoABR
# 